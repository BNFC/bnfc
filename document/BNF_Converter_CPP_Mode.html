<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
  <title>BNF Converter C++ Mode</title>
</head>
<body>
<div style="text-align: center;">
<h2>BNF Converter</h2>
<h2>C++ Mode</h2>
</div>
<br>
<h3>By Michael Pellauer</h3>
<h3>2003</h3>
One of the best features of the LBNF file format is that it is
completely independent of the target programming language. The new C++
mode allows the BNF Converter to output a compiler front end in C++
using Flex and Bison. In theory it will also work with Lex and YACC as
well, although this has not been thoroughly tested.<br>
<br>
BNFC C++ mode has been tested to work with Flex version 2.5.4 and Bison version 1.875.
1.25.<br>
<br>
BNF Converter Homepage:<br>
<a href="http://www.cs.chalmers.se/~markus/BNFC/">http://www.cs.chalmers.se/~markus/BNFC/</a><br>
<br>
Flex Homepage:<br>
<a href="http://www.gnu.org/software/flex/flex.html">http://www.gnu.org/software/flex/flex.html</a><br>
<br>
Bison Homepage:<br>
<a href="http://www.gnu.org/software/bison/bison.html">http://www.gnu.org/software/bison/bison.html</a><br>
<br>
<br>
<h3>USAGE<br>
</h3>
<div style="margin-left: 40px;"><big><span
 style="font-family: monospace;">bnfc [-m] -cpp FILENAME.cf</span></big><br
 style="font-family: monospace;">
</div>
<br>
To access the C++ mode simply pass the -cpp command to bnfc. <br>
The result will be the following files:<br>
<br>
<table cellpadding="2" cellspacing="2" border="0"
 style="text-align: left; width: 100%;">
  <tbody>
    <tr>
      <td style="vertical-align: top; text-decoration: underline;"><big><span
 style="font-family: monospace;">Filename:</span></big></td>
      <td style="vertical-align: top; text-decoration: underline;"><big><span
 style="font-family: monospace;">Description:</span></big></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><big><span
 style="font-family: monospace;">Absyn.H, Absyn.C</span></big><big><span
 style="font-family: monospace;"><br>
      </span></big><big><span style="font-family: monospace;">FILENAME.l<br>
      </span></big><big><span style="font-family: monospace;">FILENAME.y<br>
Pri</span></big><big><span style="font-family: monospace;">nter.H,
Printer.C<br>
      </span></big><big><span style="font-family: monospace;">Skeleton.H,
Skeleton.C<br>
Parser.H<br>
      </span></big><big><span style="font-family: monospace;">Test.C<br>
      </span></big><big><span style="font-family: monospace;">Makefile</span></big><br>
      </td>
      <td style="vertical-align: top;"><big><span
 style="font-family: monospace;">Abstract Syntax tree interface
&amp;&amp; classes</span></big><big><span
 style="font-family: monospace;"></span></big><br>
      <big><span style="font-family: monospace;">Flex file (lexer
specification)<br>
Bison</span></big><big><span style="font-family: monospace;"> file
(parser specification)<br>
      </span></big><big><span style="font-family: monospace;">A Pretty
Printer for the abstract syntax tree.<br>
      </span></big><big><span style="font-family: monospace;">A code
skeleton for traversing the syntax tree.<br>
      </span></big><big><span style="font-family: monospace;">Contains
definitions of tokens for the lexer.<br>
A testbench to test the final result.<br>
      </span></big><big><span style="font-family: monospace;">A
Makefile (generated only with the -m flag).</span></big><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<h3>Compiling the Compiler Front End</h3>
You can use the generated Makefile to compile the generated C++ Code
with "make" ("gmake" on some systems).<br>
<br>
If all goes well the following files should be generated:<br>
<br>
<table cellpadding="2" cellspacing="2" border="0"
 style="text-align: left; width: 100%;">
  <tbody>
    <tr>
      <td
 style="vertical-align: top; font-family: monospace; text-decoration: underline;"><big>File:</big></td>
      <td
 style="vertical-align: top; font-family: monospace; text-decoration: underline;"><big>Description:</big></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><big>Absyn.o<br>
Lexer.C<br>
Lexer.o<br>
Parser.C<br>
Parser.o<br>
Printer.o<br>
Test.o<br>
testFILENAME<br>
      </big></td>
      <td style="vertical-align: top; font-family: monospace;"><big>
Abstract Syntax class files<br>
Lexer generated by Flex<br>
Compiled Lexer<br>
Parser generated by Bison<br>
Compiled parser<br>
Compiled Pretty Printer<br>
Compiled Test Bench<br>
Compiled executable of all .o files<br>
      </big></td>
    </tr>
  </tbody>
</table>
<h3>Testing the Compiler Front End<br>
</h3>
The executable <span style="font-family: monospace; font-weight: bold;">testFILENAME</span>
(where <span style="font-family: monospace; font-weight: bold;">FILENAME</span>
is the name of the <span
 style="font-family: monospace; font-weight: bold;">.cf</span> file) may
be used to test the result of the generation. To use it simply give it
the name of a file written in the target language. If parsing is
correct, the abstract syntax tree (in Haskell-like syntax) and
linearized pretty-printed result will be shown.<br>
<br>
For example, if we had created a subset of Java called Javalette, in <span
 style="font-family: monospace; font-weight: bold;">Javalette.cf</span>:<br>
<br>
<big><span style="font-family: monospace; font-weight: bold;">&gt;
./testJavalette helloworld.jl</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">Parse Successful!</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">[Abstract Syntax]</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">(PDefList [(FuncDef
TInt(FFuncName "main")[][(SPrintString "Hello World"),</span><span
 style="font-family: monospace;"> (SReturn NoExpression)]NoSemicolon)])</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">[Linearized Tree]</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">int main () </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">{</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; printString ("Hello
World") ;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; return ;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">}</span><br
 style="font-family: monospace;">
</big><br>
If no argument is given then the executable attempts to read from stdin.<br>
<br>
<h3>The Abstract Syntax Tree</h3>
The Abstract Syntax tree is generated following the method Andrew Appel
outlines in<br>
"Modern Compiler Construction in Java"<br>
<a href="http://www.cs.princeton.edu/%7Eappel/modern/java/">http://www.cs.princeton.edu/~appel/modern/java/</a><br>
<br>
The generated code follows Appel's "non-Object Oriented method." In
addition they implement the Visitor Design Pattern.<br>
<br>
Here is an example. Let us say that we have made a simple LBNF file to
describe lists of boolean expressions, called <span
 style="font-family: monospace; font-weight: bold;">BoolExp.cf</span>:<br>
<br>
<big><span style="font-family: monospace;">--Begin LBNF file</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">PROG.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
PROG&nbsp;&nbsp; ::= [EXP] ;</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">OrExp.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
EXP&nbsp;&nbsp;&nbsp;&nbsp; ::= EXP "||" EXP1 ;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">AndExp.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
EXP1&nbsp;&nbsp;&nbsp; ::= EXP1 "&amp;&amp;" EXP2 ;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">TVal.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
EXP2&nbsp;&nbsp;&nbsp; ::= "true" ;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">FVal.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
EXP2&nbsp;&nbsp;&nbsp; ::= "false" ;<br>
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">separator EXP ";" ;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">coercions EXP 2 ;</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">--LBNF file ends here</span></big><br>
<br>
Absyn.H&nbsp; will define the following classes:<br>
<br>
<big><span style="font-family: monospace;">PROG : <span
 style="color: rgb(51, 51, 255);">public</span> Visitable</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">EXP : <span
 style="color: rgb(51, 51, 255);">public</span> Visitable <span
 style="color: rgb(204, 0, 0);">/* abstract base class */</span></span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">AndExp : <span
 style="color: rgb(51, 51, 255);">public</span> EXP</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">OrExp : <span
 style="color: rgb(51, 51, 255);">public</span> EXP</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">TVal : <span
 style="color: rgb(51, 51, 255);">public</span> EXP</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">FVal : <span
 style="color: rgb(51, 51, 255);">public</span> EXP</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">ListEXP : <span
 style="color: rgb(51, 51, 255);">public</span> Visitable</span></big><br>
<br>
Note that there is one C++ class for each Label in the LBNF file. The
top of the tree is <big><span style="font-family: monospace;">PROG</span></big>,
which is just a pointer to the top of a list:<br>
<big><span style="font-family: monospace;"><span
 style="color: rgb(204, 0, 0);"></span></span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">public class</span> PROG : <span
 style="color: rgb(51, 51, 255);">public</span> Visitable</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">{</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">public</span>:<br>
&nbsp; &nbsp; ListEXP *listexp_;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">&nbsp; </span>PROG(ListEXP p1) {
listexp_ = p1; }<br>
&nbsp; &nbsp; ~PROG() { if (listexp_) delete(listexp_); }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">&nbsp; </span><span
 style="color: rgb(51, 51, 255);">void</span> accept(Visitor *v) {
v-&gt;visitPROG(this); }</span><br style="font-family: monospace;">
<span style="font-family: monospace;">};</span></big><br>
<br>
<span style="font-weight: bold;">NOTE:</span> For simplicity this and
all examples combines the code found in <span
 style="font-family: monospace; font-weight: bold;">Absyn.H</span> and <span
 style="font-family: monospace; font-weight: bold;">Absyn.C</span>.<br>
<br>
The class <big><span style="font-family: monospace;">ListEXP</span></big>
is automatically generated to represent the list of <big><span
 style="font-family: monospace;">EXP</span></big>. This is
significantly different than the standard BNF Haskell mode, which
usesHaskell's built-in lists. Currently for each class <span
 style="font-style: italic;">NAME</span> that can be held in a list, a
class List<span style="font-style: italic;">NAME</span> is generated.
These are straightforward null-terminated linked lists and should be
familiar to all Object Oriented programmers. In the future this feature
could be extended to C++'s Standard Template Library.<br>
<br>
For example, here is <big><span style="font-family: monospace;">ListEXP</span></big>:<br>
<big><br style="font-family: monospace;">
<span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">public</span> <span
 style="color: rgb(51, 51, 255);">class</span> ListEXP : <span
 style="color: rgb(51, 51, 255);">public</span> Visitable</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">{</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">public</span>: <br>
&nbsp; &nbsp; EXP *exp_;<br>
&nbsp; &nbsp; </span><span style="font-family: monospace;">ListEXP
*listexp_;</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; &nbsp; ListEXP(EXP *p1,
ListEXP *p2) { exp_ = p1; listexp_ = p2; }<br>
&nbsp; &nbsp; ListEXP(EXP *p1) { exp_ = p1; listexp_ = 0; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">&nbsp; </span><span
 style="color: rgb(51, 51, 255);">void</span> accept(Visitor *v) {
v-&gt;visitListEXP(this); }</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">&nbsp; public</span> ListEXP reverse(<span
 style="color: rgb(51, 51, 255);">void</span>);</span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">&nbsp; public</span> ListEXP
reverse(ListEXP *prev);</span><span style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">};</span></big><br>
<br>
Note that all Lists include a generated "reverse" function used during
BNFC's optimization of Left-recursive lists. If there is sufficient
programmer demand more standard generated functions (such as delete,
lookup, etc) could be added.<br>
<br>
It is interesting to note that <big><span
 style="font-family: monospace;">ListEXP</span></big> has a pointer to <big><span
 style="font-family: monospace;">EXP</span></big>. But <big><span
 style="font-family: monospace;">EXP</span></big> is an abstract class:<big><span
 style="font-family: monospace;"><span style="color: rgb(204, 0, 0);"></span></span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">class</span> EXP </span></big><big><span
 style="font-family: monospace;">: <span
 style="color: rgb(51, 51, 255);">public</span> Visitable </span></big><big><span
 style="font-family: monospace;">{ };</span><br
 style="font-family: monospace;">
</big><br>
Abstract classes represent LBNF Categories, such as <big><span
 style="font-family: monospace;">EXP</span></big>. If a category does
not have a label with the same name (as <big><span
 style="font-family: monospace;">PROG</span></big> did in our example)
then it is declared abstract. All Labels of a category are represented
as a subclass of the abstract category. Label names should not match
category names if that category has more than one label.<br>
<br>
Here are <big><span style="font-family: monospace;">EXP</span></big>'s
subtypes in our example:<br>
<br>
<big><span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">public class</span> AndExp<span
 style="color: rgb(51, 51, 255);"></span> </span></big><big><span
 style="font-family: monospace;"> : <span
 style="color: rgb(51, 51, 255);">public</span> </span></big><big><span
 style="font-family: monospace;">EXP</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">{</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">public</span>:<br>
&nbsp; &nbsp; EXP *exp_1, *exp_2;<br>
&nbsp; &nbsp; AndExp(EXP *p1, EXP *p2) { exp_1 = p1; exp_2 = p2; }<br>
&nbsp; &nbsp; ~AndExp() { delete(exp_1); delete(exp_2); }<br>
&nbsp; &nbsp; <span style="color: rgb(51, 51, 255);">virtual void</span>
accept(Visitor *v) { v-&gt;visitAndExp(this); }</span></big><big><br
 style="font-family: monospace;">
<span style="font-family: monospace;">};</span><br
 style="font-family: monospace;">
</big><br>
<big><span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">public class</span> OrExp<span
 style="color: rgb(51, 51, 255);"></span> </span></big><big><span
 style="font-family: monospace;"> : <span
 style="color: rgb(51, 51, 255);">public</span> </span></big><big><span
 style="font-family: monospace;">EXP</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">{</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">public</span>:<br>
&nbsp; &nbsp; EXP *exp_1, *exp_2;<br>
&nbsp; &nbsp; OrExp(EXP *p1, EXP *p2) { exp_1 = p1; exp_2 = p2; }<br>
&nbsp; &nbsp; ~OrExp() { delete(exp_1); delete(exp_2); }<br>
&nbsp; &nbsp; <span style="color: rgb(51, 51, 255);">virtual void</span>
accept(Visitor *v) { v-&gt;visitOrExp(this); }</span></big><big><br
 style="font-family: monospace;">
<span style="font-family: monospace;">};<br>
</span><br style="font-family: monospace;">
<span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">class</span> TVal : <span
 style="color: rgb(51, 51, 255);">public</span> EXP</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">{</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">&nbsp;public</span>:</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; TVal() { }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; ~TVal() { }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">virtual void</span> accept(Visitor *v)
{ v-&gt;visitTVal(this); }</span><br style="font-family: monospace;">
<span style="font-family: monospace;">};</span><br
 style="font-family: monospace;">
</big><big><br>
</big><big><span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">class</span> FVal : <span
 style="color: rgb(51, 51, 255);">public</span> EXP</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">{</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">&nbsp;public</span>:</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; FVal() { }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; ~FVal() { }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="color: rgb(51, 51, 255);">virtual void</span> accept(Visitor *v)
{ v-&gt;visitFVal(this); }</span><br style="font-family: monospace;">
<span style="font-family: monospace;">};</span><br
 style="font-family: monospace;">
</big><br style="font-family: monospace;">
The programmer can then traverse through the tree using the generated
Skeleton files (see below). The PrettyPrinter is an example of this. It
contains two classes that traverse the tree and return Strings. The
"ShowAbsyn" class has a "show" function that prints a Haskell-like view
of the data type names. The &nbsp;other class "PrintAbsyn" has a
function "print" which is a pretty-printer that uses simple heuristics
(easily changed in the function"render") to linearize the syntax tree.<br>
<br>
We can see the PrettyPrinter class at work in the automatically
generated class <big><span style="font-family: monospace;">Test</span></big>.
Continuing our early example, let us write a simple input file in our
language of boolean expressions:<br>
<br>
<big><span style="font-family: monospace;">true &amp;&amp; (false ||
true);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">true;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">false || false</span><br
 style="font-family: monospace;">
</big><br>
We can now test our parser using the Test class:<br>
<br style="font-weight: bold;">
<big><span style="font-family: monospace; font-weight: bold;">&gt;
j./testBoolExp testfile</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">Parse Successful!</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">[Abstract Syntax]</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">(PROG [(AndExp TVal(OrExp
FValTVal)), TVal, (OrExp FValFVal)])</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">[Linearized Tree]</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">true &amp;&amp; (false || true) ;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">true ;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">false || false </span></big><br>
<br>
<h3>Using the Skeleton File</h3>
Now that we have sucessfully constructed a parser, it's time to do
something useful with it. This generally involves traversing the
Abstract Syntax tree and producing a new data structure, such as
translating from a high-level language to assembly code. To assist the
programmer with this process the BNF Converter's C++ Mode provides the
files <span style="font-family: monospace; font-weight: bold;">Skeleton.H</span>
and <span style="font-family: monospace; font-weight: bold;">Skeleton.C</span><br>
<br>
This file is an empty skeleton that traverses the abstract syntax tree
(currently doing nothing interesting). It uses the Visitor Design
Pattern. That is to say, each class inherits from a Visitable class,
and implement a method <big><span style="font-family: monospace;">accept(Visitor
*v)</span></big>. This method then calls the appropriate <big><span
 style="font-family: monospace;">visit(...)</span></big> method in the
Visitor class, which the Skeleton extends (double dispatch). Note that
in this method visiting a List class will not automatically visit all
of the members of that list, because compilers often want to build
context information during traversal, such as for peephole
optimizations.<br>
<br>
To use the skeleton the programmer must generally do the following:<br>
<ul>
  <li>Copy <span style="font-family: monospace; font-weight: bold;">Skeleton.H</span>
and <span style="font-family: monospace;">Skeleton.C</span> to a new file</li>
  <li>Change the name of the class from <big><span
 style="font-family: monospace;">Skeleton</span></big> to something
meaningful.</li>
  <li>Add some instance variables and a top level method which takes a <big><span
 style="font-family: monospace;">Visitable*</span></big> as a parameter
to begin the transformation.</li>
</ul>
&nbsp;<br>
From this point it should be fairly straightforward to implement the
desired algorithm. Good examples of it can be found in the two classes
in <span style="font-family: monospace; font-weight: bold;">Printer.C</span><br>
<br>
Many Visitor Design Patterns use a Visitee-traversal algorithm. That is
to say, visiting the top member of a List will automatically visit all
the members of the List. However, the BNFC-generated pattern uses
Visitor-traversal. This means that it is the Visitor's responsibility,
when visiting a list, to visit all the members in turn. This is because
certain algorithms that compilers want to implement are not
compositional. That is to say, that performing a transformation on a
single member may be quite different than performing that transformation
on a certain pattern of nodes. For example, during peephole analysis a
compiler may wish to merge to subsequent additions into a single
operation, but may want to leave single additions unchanged. This is
easier to implement if it is the Visitor doing the traversal itself.<br>
<br>
<h3>Known Issues<br>
</h3>
Here is a list of known issues with the BNF Converter's C++ Mode.<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">Keywords</span><br>
<br>
C++ contains many more keywords than Haskell, and currently there is
nothing to prevent a programmer from using these keywords in their LBNF
grammar. For example:<br>
<br>
<big><span style="font-family: monospace;">Static.&nbsp;&nbsp;
Package&nbsp;&nbsp; ::= Sychronized "." Switch ;</span></big><br>
<br>
While this will be accepted by BNF it might result in un-compilable
code, as the generated C++ occaisionally uses lowercase names for
instance variables. As such programmers should generally avoid matching
Label names with C++ keywords, or names which are used as namespace
identifiers.<br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">Reuse of
Label Names</span><br>
<br>
Reusing label names currently results in a warning from BNFC. However,
for C++ this is a much more serious issue, as they are used for class
names. For example:<br>
<br>
<big><span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">public</span> <span
 style="color: rgb(51, 51, 255);">class</span> FOO : <span
 style="color: rgb(51, 51, 255);">public</span> BAR</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">{</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;...</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">}</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;"><span
 style="color: rgb(51, 51, 255);">public class</span> FOO : <span
 style="color: rgb(51, 51, 255);">public</span> BAZ <span
 style="color: rgb(204, 0, 0);">//OOPS! That's two classes named FOO</span></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">{</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;...</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">}</span></big><br>
<br>
The best solution is for the programmer to ensure that all label names
are unique and not ignore the BNFC warning.<br>
<br>
</body>
</html>
