{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}

{-
    BNF Converter: Generate main/test module for F#
    Copyright (C) 2021  Author:  Grzegorz DZiadkiewicz

-}

module BNFC.Backend.FSharp.CFtoFSharpTest where

import Prelude hiding ((<>))

import Text.PrettyPrint

import BNFC.CF
import BNFC.Utils((+++))
import BNFC.Backend.FSharp.FSharpUtil

-- | F# comment
-- >>> comment "I'm a comment"
-- // I'm a comment
comment :: Doc -> Doc
comment d = "//" <+> d

-- | F# String concatenation
-- >>> "print a" <^> doubleQuotes "abc"
-- print a + "abc"
a <^> b = a <+> "+" <+> b

-- | Generate a test program in F#
fsharpTestfile :: String -> String -> String -> String -> String -> String -> CF -> Doc
fsharpTestfile absM lexM parM printM showM moduleName cf =
    let
        lexerName = "token"
        parserName = "p" <> topType
        printerName = "printTree " <> "prt" <> topType
        showFun = parens ("fun t -> show" <> topType <+> "t" <+> "|>" <+> "show")
        topType = text $ fixType $ firstEntry cf
    in vcat
        [ comment "automatically generated by the BNF Converter"
        , text ("module" +++ moduleName) 
        , "open System"
        , "open System.IO"
        , "open FSharp.Text.Lexing"
        , text ("open" +++ absM)
        , text ("open" +++ printM)
        , text ("open" +++ showM)
        , text ("open" +++ parM)
        , text ("open" +++ lexM)
        , ""
        , "let parse (c:TextReader) :" <+> topType <+> "="
        , nest 4 ("c |> LexBuffer<char>.FromTextReader |>" <+> parserName <+> lexerName )
        , ""
        , "let showTree (t:" <> topType <> ") : string ="
        , nest 4 (vcat ( punctuate " +" 
            [ doubleQuotes "[Abstract syntax]\\n\\n"
            , showFun <+> "t" 
            , doubleQuotes "\\n\\n"
            , doubleQuotes "[Linearized tree]\\n\\n"
            , printerName <+> "t"
            , doubleQuotes "\\n" ] ) )
        , ""
        , "[<EntryPoint>]"
        , "let main args ="
        , nest 4 $ vcat
            [ "use channel ="
            , nest 4 $ vcat
                [ "if Array.length args > 0 then File.OpenText args.[0] :> TextReader"
                , "else stdin" ]
            , "try"
            , nest 4 $ vcat
                [ "channel |> parse |> showTree |> printfn \"%s\""
                , "0"]
            , "with BnfcUtil.ParseError (start_pos, end_pos) ->"
            , nest 4 $ vcat
                [ "printfn" <+> doubleQuotes "Parse error at %d.%d-%d.%d"
                , nest 4 $ vcat
                    [ "start_pos.pos_lnum (start_pos.pos_cnum - start_pos.pos_bol)"
                    , "end_pos.pos_lnum (end_pos.pos_cnum - end_pos.pos_bol)" ]
                , "1" ]]
            ]
